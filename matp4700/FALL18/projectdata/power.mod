# assign power to meet demand
#
# have available hydro, solar, wind, steam plant
#
# looking to allocate over some period of time,
# eg, in six hours slots for a week.
#
# know total demand.
# don't worry about the demand network, just overall demand.
#
# know solar and wind output.
#
# can use solar and wind to pump water uphill,
# as well as just to meet demand.
#
# can release water to generate hydro.
#
# have network of reservoirs, so water may flow from
# one reservoir to another, with some time delay.
# to simplify, assume all delays are one time period,
# both downhill and uphill.
#
# have water flowing in to reservoirs from rain.
#
# have available a steam plant, which has ramping constraints
# as well as capacity limits.
# it also has a piecewise linear convex cost function.
#
# have a spinning constraint:
# ensure that always have some reserve power available,
# in case demand is higher than expected, or renewable generation
# is lower than expected.
#
# aim is to minimize cost of running steam plant.
#
# to avoid end effects, want:
# (1) total hydro available at end = total hydro available at beginning
# (2) first period steam level within ramping level of final period level.
# (3) each reservoir is above some percentage of its initial level.
#

#
# sets
#

set HYDRO;  # reservoirs, plus final sink
set SOLAR;  # solar arrays
set WIND;   # wind farms

set HYDROCHILD{HYDRO} within HYDRO;
            # each hydro reservoir releases to a unique next reservoir.
            # the sink reservoir does not have a "next reservoir"

set SOLARPUMP{SOLAR} within HYDRO;
            # each solar array can pump water into a set of reservoirs,
            # from their HYDROCHILD reservoir.

set WINDPUMP{WIND} within HYDRO;
            # each wind farm can pump water into a set of reservoirs,
            # from their HYDROCHILD reservoir.

#
# parameters
#

param horizon;  #  number of time periods

param demand{1..horizon};  # total power needs

param windgen{WIND,1..horizon};  # forecast wind output for each wind farm
param solargen{SOLAR,1..horizon};  # forecast wind output for each solar array

param releaserate{HYDRO};  # rate at which hydro plant can release water

param releaseratepower{HYDRO};  # amount of power generated by releasing
                                # one unit of water

param hydrocapacity{HYDRO}; # capacity of reservoir

param hydroelevation{HYDRO}; # elevation of each reservoir
                             # at each hydro plant

param hydroinitiallevel{HYDRO}; # initial level of reservoirs

param hydrofuturepower{h in HYDRO}
  := releaseratepower[h]
   + sum{j in HYDROCHILD[h]} releaseratepower[j]
   + sum{j in HYDROCHILD[h], k in HYDROCHILD[j]} releaseratepower[k];
   #  calculated parameter equal to the
   #  possible future power generation from one acre-foot in reservoir h,
   #  from all downstream releases.

param hydrorainflow{HYDRO,1..horizon} default 0;
   # natural replensihment of reservoirs

param steamcapacity;  # maximum power output of steam plant

param steamramprate;  # maximum change in output from steam plant
                      # from one period to the next

param watersolarpower{i in SOLAR, j in SOLARPUMP[i]};
             # amount of water that can be pumped into reservoir j
             # for one unit of power frow solar array i.

param waterwindpower{i in WIND, j in WINDPUMP[i]};
             # amount of water that can be pumped into reservoir j
             # for one unit of power frow wind farm i.

param steamslope{1..3};
param steamintercept{1..3};
  # cost of steam generation is
  # max_k{steamintercept[k]+steamslope[k]*steamgen[t]}
  # for each period t.

param spinlevel;   # required slack in production availability
                   # to allow for sudden increase in production
                   # if necessary

#
# variables
#

var steamgen{1..horizon} >= 0, <= steamcapacity;
    # amount of power generated at steam plant

var steamspin{1..horizon} >= 0, <= steamramprate;
    # amount of power generated at steam plant

var steamcost{1..horizon} >= 0;  # cost of power generated at steam plant

var solarpower{SOLAR,1..horizon} >= 0;
     # amount of power generated at solar arrays that is used to
     # meet demand

var solarpump{i in SOLAR, j in SOLARPUMP[i], 1..horizon} >= 0;
     # amount of power generated at solar arrays that is used to
     # pump water

var windpower{WIND,1..horizon} >= 0;
     # amount of power generated at wind farms that is used to
     # meet demand

var windpump{i in WIND, j in WINDPUMP[i], 1..horizon} >= 0;
     # amount of power generated at wind farms that is used to
     # pump water

var hydrorelease{h in HYDRO, 1..horizon} >= 0, <= releaserate[h];
     # amount of water released during period

var hydrospin{h in HYDRO, 1..horizon} >= 0, <= releaserate[h];
     # amount of water available to meet spin constraint

#var hydropump{HYDRO, 1..horizon} >= 0; # amount of water pumped into reservoir
#                                  # during period

var hydrolevel{h in HYDRO, 1..horizon} >= 0 <= hydrocapacity[h];
  # water level at beginning of each period

var hydrolevelfinal{h in HYDRO} >= 0, <= hydrocapacity[h];
  # water level at end of final period.
  # must be at least 80% of initial level.

###################################################

# objective function

minimize totalcost: sum{t in 1..horizon} steamcost[t];

#
# constraints
#

# get piecewise linear steamcost

subject to findobj {k in 1..3, t in 1..horizon}:
  steamcost[t] >= steamintercept[k] + steamslope[k] * steamgen[t];

# need to meet demand

subject to meetdemand {t in 1..horizon}:
  sum{i in SOLAR} solarpower[i,t] + sum{j in WIND} windpower[j,t]
  + steamgen[t] + sum{h in HYDRO} releaseratepower[h]*hydrorelease[h,t]
  >= demand[t];

# obey generation constraints on solar

subject to solarcap{j in SOLAR, t in 1..horizon}:
  sum{h in SOLARPUMP[j]} solarpump[j,h,t]+solarpower[j,t] <= solargen[j,t];

# obey generation constraints on wind

subject to windcap{j in WIND, t in 1..horizon}:
  sum{h in WINDPUMP[j]} windpump[j,h,t]+windpower[j,t] <= windgen[j,t];

# obey rampup constraints on steam generation

subject to rampup{t in 1..horizon-1}:
  steamgen[t+1] <= steamgen[t] + steamramprate;

# obey rampdown constraints on steam generation

subject to rampdown{t in 1..horizon-1}:
  steamgen[t+1] >= steamgen[t] - steamramprate;

# ensure first and last steam levels are close, part 1

subject to rampuphorizon: steamgen[horizon] <= steamgen[1] + steamramprate;

# ensure first and last steam levels are close, part 2

subject to rampdownhorizon: steamgen[horizon] >= steamgen[1] - steamramprate;

# update the water level in the reservoirs

subject to hydrolevelupdate{h in HYDRO, t in 1..horizon-1}:
  hydrolevel[h,t+1] = hydrolevel[h,t] # level in previous period
    - hydrorelease[h,t] # water released to flow downstream
    + hydrorainflow[h,t] # inflow from rain
    + sum{k in HYDRO : h in HYDROCHILD[k]} hydrorelease[k,t] # inflow from upstream reservoir releases
    + sum{i in SOLAR : h in SOLARPUMP[i]} solarpump[i,h,t]*watersolarpower[i,h] # inflow due to solar power
    + sum{i in WIND : h in WINDPUMP[i]} windpump[i,h,t]*waterwindpower[i,h] # inflow due to wind power
    - sum{i in SOLAR, k in SOLARPUMP[i] : h in HYDROCHILD[k]}
          solarpump[i,k,t]*watersolarpower[i,k] # outflow due to solar power
    - sum{i in WIND, k in WINDPUMP[i] : h in HYDROCHILD[k]}
          windpump[i,k,t]*waterwindpower[i,k] # outflow due to wind power
;

# get the level at the start of the next week
#
# structurally, same as previous constraint hydroplevelupdate, but with t=horizon.

subject to hydrolevelfinalcal{h in HYDRO}:
  hydrolevelfinal[h] =
 hydrolevel[h,horizon] - hydrorelease[h,horizon] + hydrorainflow[h,horizon]
+ sum{k in HYDRO : h in HYDROCHILD[k]} hydrorelease[k,horizon]
+ sum{i in SOLAR : h in SOLARPUMP[i]} solarpump[i,h,horizon]*watersolarpower[i,h]
+ sum{i in WIND : h in WINDPUMP[i]} windpump[i,h,horizon]*waterwindpower[i,h]
    - sum{i in SOLAR, k in SOLARPUMP[i] : h in HYDROCHILD[k]}
          solarpump[i,k,horizon]*watersolarpower[i,k]
    - sum{i in WIND, k in WINDPUMP[i] : h in HYDROCHILD[k]}
          windpump[i,k,horizon]*waterwindpower[i,k]
;

# the spin reserve constraint:
# excess power available from steam and hydro must be at least spinlevel

subject to findhydrospin1{h in HYDRO, t in 1..horizon}:
hydrospin[h,t] <= releaserate[h]-hydrorelease[h,t];
  # limit on spin availability from hydro due to limit on release rate
  # from reservoir

subject to findhydrospin2{h in HYDRO, t in 1..horizon}:
hydrospin[h,t] <= hydrolevel[h,t]-hydrorelease[h,t];
  # limit on release rate due to current water level in reservoir

subject to findsteamspin0:
steamspin[1] <= steamgen[horizon]+steamramprate-steamgen[1];
  # limit on spin available from steam plant at period 1
  # due to ramping constraint.

subject to findsteamspin{t in 1..horizon-1}:
steamspin[t+1] <= steamgen[t]+steamramprate-steamgen[t+1];
  # limit on spin available from steam plant at period t
  # due to ramping constraint

subject to findsteamspincap{t in 1..horizon}:
steamspin[t] + steamgen[t] <= steamcapacity;
  # limit on spin available from steam plant at period t
  # due to capacity limit of steam plant.

subject to spin {t in 1.. horizon}:
  steamspin[t] + sum{h in HYDRO} hydrospin[h,t]*releaseratepower[h]
    >= spinlevel;
  # need to have enough spin available at each time period.

# set the initial water level in the reservoirs

subject to hydrolevel0{h in HYDRO}: hydrolevel[h,1] = hydroinitiallevel[h];

# final level must be at least 80% of initial level.
subject to keepwater{h in HYDRO}:
  hydrolevelfinal[h] >= 0.8* hydroinitiallevel[h];


# equate initial and final potential energies

subject to potentiallevels:
  sum{h in HYDRO} hydrolevelfinal[h] * hydrofuturepower[h] >=
  sum{h in HYDRO} hydroinitiallevel[h] * hydrofuturepower[h];
