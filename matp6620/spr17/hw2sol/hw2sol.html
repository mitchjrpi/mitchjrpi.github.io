<!DOCTYPE html PUBLIC "-//W3C//DTD HTML 4.01 Transitional//EN"  
  "http://www.w3.org/TR/html4/loose.dtd">  
<html > 
<head><title></title> 
<meta http-equiv="Content-Type" content="text/html; charset=iso-8859-1"> 
<meta name="generator" content="TeX4ht (http://www.cse.ohio-state.edu/~gurari/TeX4ht/)"> 
<meta name="originator" content="TeX4ht (http://www.cse.ohio-state.edu/~gurari/TeX4ht/)"> 
<!-- html --> 
<meta name="src" content="hw2sol.tex"> 
<meta name="date" content="2017-02-12 21:57:00"> 
<link rel="stylesheet" type="text/css" href="hw2sol.css"> 
</head><body 
>
<div class="center" 
>
<!--l. 42--><p class="noindent" >
<!--l. 44--><p class="noindent" ><a 
href="http://www.rpi.edu/~mitchj/matp6620" ><span 
class="cmr-12">MATP6620/ISYE6760 Combinatorial Optimization &amp; Integer Programming</span></a><br />
<span 
class="cmr-12">Homework 2 Solutions</span>
</div>
                                                                                         <div class="flushright" 
>
<!--l. 49--><p class="noindent" >
 Due: Friday, February 10, 2017, in class.<br />
Penalty for late homeworks: 10% for each day or part of a day.</div>
     <ol  class="enumerate1" >
     <li 
  class="enumerate" id="x1-3x1">A method for representing a spanning tree on the complete graph on vertices <span 
class="cmsy-10">{</span>1<span 
class="cmmi-10">,</span><span 
class="cmmi-10">&#x2026;</span><span 
class="cmmi-10">,n</span><span 
class="cmsy-10">} </span>as a string of <span 
class="cmmi-10">n </span><span 
class="cmsy-10">- </span>2
     numbers was presented in class. Find the trees with 8 vertices corresponding to the following
     strings:
         <ol  class="enumerate2" >
         <li 
  class="enumerate" id="x1-5x1">543156.
         </li>
         <li 
  class="enumerate" id="x1-7x2">768773.
         </li>
         <li 
  class="enumerate" id="x1-9x3">543854.</li></ol>
     <!--l. 100--><p class="noindent" ><span 
class="cmbx-10">Solution:</span>
     <!--l. 175--><p class="noindent" >   
<img src=hw2q1sol.png>
     </li>
     <li 
  class="enumerate" id="x1-11x2">Show that <div class="eqnarray">
     <center class="math-display" >
     <img 
src="hw2sol0x.png" alt="             4
S  :=  {x &#x2208; B : 97x1 +32x2 + 25x3 + 20x4 &#x2264; 139}
    =  {x &#x2208; B4 : 2x1 + x2 + x3 + x4 &#x2264; 3}
    =  {x &#x2208; B4 : x1 + x2 + x3 &#x2264; 2,x1 +x3 + x4 &#x2264; 2,x1 + x2 + x4 &#x2264; 2}.
     " class="math-display" ></center>
     </div>Which formulation do you think is most effective for solving max<span 
class="cmsy-10">{</span><span 
class="cmmi-10">c</span><sup><span 
class="cmmi-7">T</span></sup><span 
class="cmmi-10">x </span>: <span 
class="cmmi-10">x </span><span 
class="cmsy-10">&#x2208; </span><span 
class="cmmi-10">S</span><span 
class="cmsy-10">}</span>? Why?
     <!--l. 232--><p class="noindent" ><span 
class="cmbx-10">Solution:</span>
     <!--l. 235--><p class="noindent" >The three formulations of <span 
class="cmmi-10">S </span>are equivalent since all three sets consist of the points
     <center class="math-display" >
     <img 
src="hw2sol1x.png" alt="(1,1,0,0),(1,0,1,0),(1,0,0,1),(0,1,1,1)
     " class="math-display" ></center>
     <!--l. 240--><p class="nopar" >
     and all binary points that are smaller than at least one of these points.
     <!--l. 243--><p class="noindent" >The most effective formulation is the one with the tightest LP relaxation. Denote the feasible regions of the LP
     relaxations as <div class="eqnarray">
     <center class="math-display" >
     <img 
src="hw2sol2x.png" alt="S1 :=  {x &#x2208; &#x211D;4 : 97x1 + 32x2 + 25x3 + 20x4 &#x2264; 139,0 &#x2264; x &#x2264; e}
S2 :=  {x &#x2208; &#x211D;4 : 2x1 + x2 + x3 + x4 &#x2264; 3,0 &#x2264; x &#x2264; e}
S  :=  {x &#x2208; &#x211D;4 : x + x + x &#x2264; 2,x  + x + x &#x2264; 2,x  +x  + x &#x2264; 2,0 &#x2264; x &#x2264; e}
 3               1   2   3     1    3   4     1    2   4
     " class="math-display" ></center>
     </div>where <span 
class="cmmi-10">e </span>denotes the vector of ones. Note that
     <center class="math-display" >
     <img 
src="hw2sol3x.png" alt="x = (0.5,1,1,0) &#x2208; S2 \ S3
     " class="math-display" ></center>
     <!--l. 266--><p class="nopar" >
     while
     <center class="math-display" >
     <img 
src="hw2sol4x.png" alt="x = (0.5,0.75,0.75,0.75) &#x2208; S3 \S2,
     " class="math-display" ></center>
     <!--l. 270--><p class="nopar" >
     so neither set contains the other.
     <!--l. 273--><p class="noindent" >If <span 
class="cmmi-10">x </span><span 
class="cmsy-10">&#x2208; </span><span 
class="cmmi-10">S</span><sub><span 
class="cmr-7">2</span></sub> then
                                                                                         
                                                                                         
     <center class="math-display" >
     <img 
src="hw2sol5x.png" alt="32(2x1 + x2 + x3 + x4)+ 33x1 &#x2264; 32(3)+ 33,
     " class="math-display" ></center>
     <!--l. 276--><p class="nopar" >
     or equivalently
     <center class="math-display" >
     <img 
src="hw2sol6x.png" alt="97x1 + 32x2 + 32x3 +32x4 &#x2264; 129,
     " class="math-display" ></center>
     <!--l. 280--><p class="nopar" >
     which dominates the inequality defining&#x00A0;<span 
class="cmmi-10">S</span><sub><span 
class="cmr-7">1</span></sub>, so <span 
class="cmmi-10">S</span><sub><span 
class="cmr-7">2</span></sub> <span 
class="cmsy-10">&#x2286; </span><span 
class="cmmi-10">S</span><sub><span 
class="cmr-7">1</span></sub>.
     <!--l. 283--><p class="noindent" >Similarly, if <span 
class="cmmi-10">x </span><span 
class="cmsy-10">&#x2208; </span><span 
class="cmmi-10">S</span><sub><span 
class="cmr-7">3</span></sub> then
     <center class="math-display" >
     <img 
src="hw2sol7x.png" alt="18.5(x1 + x2 + x3)+ 6.5(x1 + x3 + x4)+ 13.5(x1 + x2 + x4) + 58.5x1 &#x2264; 18.5(2) + 6.5(2)+ 13.5(2)+ 58.5,
     " class="math-display" ></center>
     <!--l. 287--><p class="nopar" >
     or equivalently
     <center class="math-display" >
     <img 
src="hw2sol8x.png" alt="97x1 +32x2 + 25x3 + 20x4 &#x2264; 135.5,
     " class="math-display" ></center>
     <!--l. 291--><p class="nopar" >
     which dominates the inequality defining&#x00A0;<span 
class="cmmi-10">S</span><sub><span 
class="cmr-7">1</span></sub>, so <span 
class="cmmi-10">S</span><sub><span 
class="cmr-7">2</span></sub> <span 
class="cmsy-10">&#x2286; </span><span 
class="cmmi-10">S</span><sub><span 
class="cmr-7">1</span></sub>.
     <!--l. 294--><p class="noindent" >Thus, <span 
class="cmmi-10">S</span><sub><span 
class="cmr-7">1</span></sub> is the weakest formulation. It is not easy to compare the other two formulations; the better one will
     depend on the objective function. The inequalities in the third formulation can be obtained by one C-G
     rounding from the second formulation, and vice versa.
     </li>
     <li 
  class="enumerate" id="x1-15x3">Assume that we have a polynomial time algorithm for <span 
class="cmti-10">computing the number of nodes </span>of the largest node
     packing for any graph <span 
class="cmmi-10">G </span>= (<span 
class="cmmi-10">V,E</span>). This algorithm will tell us the number of nodes in the optimal
     packing but it will <span 
class="cmti-10">not </span>tell us the nodes that are used in the optimal packing. Prove that we can
     use this algorithm as a subroutine in a polynomial time algorithm for <span 
class="cmti-10">finding the nodes </span>in the
     largest node packing. Be careful with your description of how you proceed in each case in your
     algorithm.
     <!--l. 458--><p class="noindent" ><span 
class="cmbx-10">Solution:</span>
     <!--l. 461--><p class="noindent" >Given a graph <span 
class="cmmi-10">H </span>= (<span 
class="cmmi-10">U,F</span>), let <span 
class="cmmi-10">p</span>(<span 
class="cmmi-10">H</span>) denote the number of nodes in the largest node packing
     on&#x00A0;<span 
class="cmmi-10">H</span>.
     <!--l. 464--><p class="noindent" >For any <span 
class="cmmi-10">U </span><span 
class="cmsy-10">&#x2286; </span><span 
class="cmmi-10">V </span>, the subgraph induced by <span 
class="cmmi-10">U </span>is denoted (<span 
class="cmmi-10">U,E</span>(<span 
class="cmmi-10">U</span>)).
     <!--l. 466--><p class="noindent" >For any <span 
class="cmmi-10">v </span><span 
class="cmsy-10">&#x2208; </span><span 
class="cmmi-10">V </span>, the set of neighbors of <span 
class="cmmi-10">v </span>is denoted <span 
class="cmmi-10">n</span>(<span 
class="cmmi-10">v</span>).
     <!--l. 468--><p class="noindent" >An algorithm for computing the nodes in the largest node packing:
                                                                                         
                                                                                         
         <ol  class="enumerate2" >
         <li 
  class="enumerate" id="x1-17x1">Initialize: Nodes in node packing is initialized to <span 
class="cmmi-10">W </span>= <span 
class="cmsy-10">&#x2205;</span>. Nodes still to investigate is initialized
         to&#x00A0;<span 
class="cmmi-10">U </span>= <span 
class="cmmi-10">V </span>. Initial graph is (<span 
class="cmmi-10">U,E</span>).
         </li>
         <li 
  class="enumerate" id="x1-19x2">While <span 
class="cmmi-10">U</span><span 
class="cmmi-10">&#x2260;</span><span 
class="cmsy-10">&#x2205;</span>:
             <ol  class="enumerate3" >
             <li 
  class="enumerate" id="x1-21x1">Determine <span 
class="cmmi-10">p</span>(<span 
class="cmmi-10">U,E</span>(<span 
class="cmmi-10">U</span>)).
             </li>
             <li 
  class="enumerate" id="x1-23x2">Pick <span 
class="cmmi-10">v </span><span 
class="cmsy-10">&#x2208; </span><span 
class="cmmi-10">U</span>. Find <span 
class="cmmi-10">p</span>(<span 
class="cmmi-10">U </span><span 
class="cmsy-10">\ </span><span 
class="cmmi-10">v,E</span>(<span 
class="cmmi-10">U </span><span 
class="cmsy-10">\ </span><span 
class="cmmi-10">v</span>)).
             </li>
             <li 
  class="enumerate" id="x1-25x3">If <span 
class="cmmi-10">p</span>((<span 
class="cmmi-10">U </span><span 
class="cmsy-10">\ </span><span 
class="cmmi-10">v,E</span>(<span 
class="cmmi-10">U </span><span 
class="cmsy-10">\ </span><span 
class="cmmi-10">v</span>)) <span 
class="cmmi-10">&#x003C; p</span>(<span 
class="cmmi-10">U,E</span>(<span 
class="cmmi-10">U</span>)) then <span 
class="cmmi-10">v </span>is in an optimal node packing, and none of its
             neighbors are in this packing. Update <span 
class="cmmi-10">W </span><span 
class="cmsy-10">&#x2190; </span><span 
class="cmmi-10">W </span><span 
class="cmsy-10">&#x222A; </span><span 
class="cmmi-10">v</span>, <span 
class="cmmi-10">U </span><span 
class="cmsy-10">&#x2190; </span><span 
class="cmmi-10">U </span><span 
class="cmsy-10">\{</span><span 
class="cmmi-10">v </span><span 
class="cmsy-10">&#x222A; </span><span 
class="cmmi-10">n</span>(<span 
class="cmmi-10">v</span>)<span 
class="cmsy-10">}</span>. <br 
class="newline" /><span 
class="cmti-10">Else</span>, <span 
class="cmmi-10">p</span>((<span 
class="cmmi-10">U </span><span 
class="cmsy-10">\ </span><span 
class="cmmi-10">v,E</span>(<span 
class="cmmi-10">U </span><span 
class="cmsy-10">\ </span><span 
class="cmmi-10">v</span>)) = <span 
class="cmmi-10">p</span>(<span 
class="cmmi-10">U,E</span>(<span 
class="cmmi-10">U</span>)) so there exists an optimal node packing that does not
             include&#x00A0;<span 
class="cmmi-10">v</span>. Update <span 
class="cmmi-10">U </span><span 
class="cmsy-10">&#x2190; </span><span 
class="cmmi-10">U </span><span 
class="cmsy-10">\ </span><span 
class="cmmi-10">v</span>.
             </li>
             <li 
  class="enumerate" id="x1-27x4">End while.</li></ol>
         </li>
         <li 
  class="enumerate" id="x1-29x3">Return <span 
class="cmmi-10">W</span>, the nodes in an optimal node packing.</li></ol>
     <!--l. 490--><p class="noindent" >The number of iterations is bounded by <span 
class="cmsy-10">|</span><span 
class="cmmi-10">V </span><span 
class="cmsy-10">|</span>, and the work per iteration is bounded by the work of the
     subroutine plus a linear function of&#x00A0;<span 
class="cmsy-10">|</span><span 
class="cmmi-10">E</span><span 
class="cmsy-10">|</span>.
     </li>
     <li 
  class="enumerate" id="x1-31x4">Using the <span 
class="cmti-10">Hamiltonian path </span>problem, or otherwise, show that the following problem is <span 
class="cmsy-10"><img 
src="cmsy10-4e.png" alt="N" class="10x-x-4e" /><img 
src="cmsy10-50.png" alt="P" class="10x-x-50" /></span>
     -complete.
         <div class="quote">
         <!--l. 529--><p class="noindent" >Given a graph <span 
class="cmmi-10">G </span>= (<span 
class="cmmi-10">V,E</span>) is there a subset <span 
class="cmmi-10">E</span><span 
class="cmsy-10">&#x2032; &#x2286; </span><span 
class="cmmi-10">E </span>where <span 
class="cmmi-10">G</span><span 
class="cmsy-10">&#x2032; </span>= (<span 
class="cmmi-10">V,E</span><span 
class="cmsy-10">&#x2032;</span>) is connected and
         every vertex in <span 
class="cmmi-10">G</span><span 
class="cmsy-10">&#x2032; </span>has degree no larger than&#x00A0;3?</div>
     <!--l. 533--><p class="noindent" >(The Hamiltonian path problem is: Given a graph <span 
class="cmmi-10">H </span>= (<span 
class="cmmi-10">U,F</span>), does there exist a path which visits all the
     vertices of <span 
class="cmmi-10">H </span>exactly once? You may assume that this problem is <span 
class="cmsy-10"><img 
src="cmsy10-4e.png" alt="N" class="10x-x-4e" /><img 
src="cmsy10-50.png" alt="P" class="10x-x-50" /></span>
     -complete.)
     <!--l. 539--><p class="noindent" ><span 
class="cmbx-10">Solution:</span>
     <!--l. 542--><p class="noindent" >The given problem is in <span 
class="cmsy-10"><img 
src="cmsy10-4e.png" alt="N" class="10x-x-4e" /><img 
src="cmsy10-50.png" alt="P" class="10x-x-50" /></span>.
     <!--l. 544--><p class="noindent" >We reduce Hamiltonian path on the graph <span 
class="cmmi-10">H </span>= (<span 
class="cmmi-10">U,F</span>) to the given problem:
     <!--l. 546--><p class="noindent" >For each vertex <span 
class="cmmi-10">u </span><span 
class="cmsy-10">&#x2208; </span><span 
class="cmmi-10">U</span>, add an additional vertex of degree&#x00A0;1, where <span 
class="cmmi-10">u </span>is the only neighbor of this additional
     node.
     <!--l. 549--><p class="noindent" >If the modified graph has an appropriate subset <span 
class="cmmi-10">E</span><span 
class="cmsy-10">&#x2032; </span>then we can recover a Hamiltonian path by deleting the
     added vertices and edges.
     <!--l. 552--><p class="noindent" >For an example of the construction, see the following:
     <div class="center" 
>
<!--l. 553--><p class="noindent" >
                                                                                         
                                                                                         
<img src=hw2q4sol.png>
<!--l. 588--><p class="noindent" >
</div>
     </li>
     <li 
  class="enumerate" id="x1-33x5">Polynomially reduce 3-SAT (a strongly <span 
class="cmsy-10"><img 
src="cmsy10-4e.png" alt="N" class="10x-x-4e" /><img 
src="cmsy10-50.png" alt="P" class="10x-x-50" /></span>-complete problem) to <span 
class="cmcsc-10">0-1</span><span 
class="cmcsc-10">&#x00A0;K<span 
class="small-caps">n</span><span 
class="small-caps">a</span><span 
class="small-caps">p</span><span 
class="small-caps">s</span><span 
class="small-caps">a</span><span 
class="small-caps">c</span><span 
class="small-caps">k</span> W<span 
class="small-caps">i</span><span 
class="small-caps">t</span><span 
class="small-caps">h</span> L<span 
class="small-caps">o</span><span 
class="small-caps">w</span><span 
class="small-caps">e</span><span 
class="small-caps">r</span> B<span 
class="small-caps">o</span><span 
class="small-caps">u</span><span 
class="small-caps">n</span><span 
class="small-caps">d</span></span>,
     that is,
         <div class="quote">
         <!--l. 613--><p class="noindent" >Given vectors <span 
class="cmmi-10">c </span>and <span 
class="cmmi-10">a </span>in <span 
class="cmsy-10">&#x211C;</span><sup><span 
class="cmmi-7">n</span></sup> and scalars <span 
class="cmmi-10">b </span>and <span 
class="cmmi-10">&#x03B4;</span>, does there exist binary <span 
class="cmmi-10">x </span>with <span 
class="cmmi-10">c</span><sup><span 
class="cmmi-7">T</span></sup><span 
class="cmmi-10">x </span><span 
class="cmsy-10">&#x2265; </span><span 
class="cmmi-10">&#x03B4; </span>and
         <span 
class="cmmi-10">a</span><sup><span 
class="cmmi-7">T</span></sup><span 
class="cmmi-10">x </span><span 
class="cmsy-10">&#x2264; </span><span 
class="cmmi-10">b</span>?</div>
     <!--l. 617--><p class="noindent" >(Notice that this is a problem solvable in pseudopolynomial time.)
     <!--l. 619--><p class="noindent" >(Hint: We know how to transform a clause into an inequality in binary variables. This can be refined slightly
     by introducing additional binary variables to give an equivalent <span 
class="cmti-10">equality </span>in binary variables. Construct a sum
     <span 
class="cmmi-10">a</span><sup><span 
class="cmmi-7">T</span></sup><span 
class="cmmi-10">x </span>= <span 
class="cmmi-10">b </span>of these equalities, such that the single equality <span 
class="cmmi-10">a</span><sup><span 
class="cmmi-7">T</span></sup><span 
class="cmmi-10">x </span>= <span 
class="cmmi-10">b </span>is satisfied by binary variables if and only if
     all of the original equalities can be satisfied simultaneously by binary variables. We can then get the equivalent
     <span 
class="cmcsc-10">0-1 K<span 
class="small-caps">n</span><span 
class="small-caps">a</span><span 
class="small-caps">p</span><span 
class="small-caps">s</span><span 
class="small-caps">a</span><span 
class="small-caps">c</span><span 
class="small-caps">k</span> </span>problem by taking <span 
class="cmmi-10">c </span>= <span 
class="cmmi-10">a </span>and <span 
class="cmmi-10">&#x03B4; </span>= <span 
class="cmmi-10">b</span>: Does there exist a binary <span 
class="cmmi-10">x </span>satisfying <span 
class="cmmi-10">a</span><sup><span 
class="cmmi-7">T</span></sup><span 
class="cmmi-10">x </span><span 
class="cmsy-10">&#x2264; </span><span 
class="cmmi-10">b </span>and
     <span 
class="cmmi-10">a</span><sup><span 
class="cmmi-7">T</span></sup><span 
class="cmmi-10">x </span><span 
class="cmsy-10">&#x2265; </span><span 
class="cmmi-10">b</span>?)
     <!--l. 632--><p class="noindent" ><span 
class="cmbx-10">Solution:</span>
     <!--l. 635--><p class="noindent" >We are given an instance of 3-SAT with <span 
class="cmmi-10">n </span>boolean variables and <span 
class="cmmi-10">m </span>clauses, each containing exactly three
     literals. We show a slightly stronger result than in the statement of the question: we show that we can
     construct a reduction where <span id="textcolor1"><span 
class="cmmi-10">a </span><span 
class="cmsy-10">&#x2265; </span>0 and <span 
class="cmmi-10">c </span><span 
class="cmsy-10">&#x2265; </span>0</span>.
         <ul class="itemize1">
         <li class="itemize">First, introduce two sets of binary variables: <span 
class="cmmi-10">x </span><span 
class="cmsy-10">&#x2208; </span><span 
class="msbm-10">B</span><sup><span 
class="cmmi-7">n</span></sup> and <span 
class="cmmi-10">y </span><span 
class="cmsy-10">&#x2208; </span><span 
class="msbm-10">B</span><sup><span 
class="cmmi-7">n</span></sup>, with
         <center class="math-display" >
         <img 
src="hw2sol9x.png" alt="xi = 1, yi = 0 if corresponding boolean variable is true
xi = 0, yi = 1 if corresponding boolean variable is false.
         " class="math-display" ></center>
         <!--l. 647--><p class="nopar" >
         We need to add the constraints <span 
class="cmmi-10">x</span><sub><span 
class="cmmi-7">i</span></sub> + <span 
class="cmmi-10">y</span><sub><span 
class="cmmi-7">i</span></sub> = 1. Each clause <span 
class="cmmi-10">C</span><sub><span 
class="cmmi-7">j</span></sub> can be expressed as an inequality
         constraint
         <center class="math-display" >
         <img 
src="hw2sol10x.png" alt=" &#x2211;       &#x2211;
    xi +     yi &#x2265; 1,
i&#x2208;C+j     i&#x2208;C-j
         " class="math-display" ></center>
         <!--l. 652--><p class="nopar" >
         where <span 
class="cmmi-10">C</span><sub><span 
class="cmmi-7">j</span></sub><sup><span 
class="cmr-7">+</span></sup> and <span 
class="cmmi-10">C</span><sub><span 
class="cmmi-7">j</span></sub><sup><span 
class="cmsy-7">-</span></sup> represent the literals in <span 
class="cmmi-10">C</span><sub><span 
class="cmmi-7">j</span></sub> corresponding to original variables and negated variables,
         respectively.
         </li>
         <li class="itemize">The inequalities for the constraints can be turned into equalities through the introduction of 2<span 
class="cmmi-10">m </span>more
         binary variables, <span 
class="cmmi-10">z</span><sub><span 
class="cmmi-7">j</span></sub><sup><span 
class="cmr-7">1</span></sup> and <span 
class="cmmi-10">z</span><sub><span 
class="cmmi-7">j</span></sub><sup><span 
class="cmr-7">2</span></sup> for <span 
class="cmmi-10">j </span>= 1<span 
class="cmmi-10">,</span><span 
class="cmmi-10">&#x2026;</span><span 
class="cmmi-10">,m</span>, with the constraints written
         <center class="math-display" >
         <img 
src="hw2sol11x.png" alt=" &#x2211;  x +  &#x2211;   y + z1+ z2= 3.
   + i     -  i   j   j
i&#x2208;Cj     i&#x2208;Cj
         " class="math-display" ></center>
         <!--l. 661--><p class="nopar" >
         (If a clause only contains one literal then we don&#8217;t need the <span 
class="cmmi-10">z </span>variables; if a clause contains exactly two
         literals then we only need <span 
class="cmmi-10">z</span><sub><span 
class="cmmi-7">j</span></sub><sup><span 
class="cmr-7">1</span></sup> and not&#x00A0;<span 
class="cmmi-10">z</span><sub><span 
class="cmmi-7">j</span></sub><sup><span 
class="cmr-7">2</span></sup>.)
         </li>
         <li class="itemize">The 3-SAT problem is equivalent to the binary integer program
         <table 
class="equation"><tr><td><a 
 id="x1-34r1"></a>
         <center class="math-display" >
         <img 
src="hw2sol12x.png" alt="&#x2211;         &#x2211;
  i&#x2208;C+ xi +  i&#x2208;C- yi + z1j + z2j = 3, j = 1,...,m
xi + jyi = 1, i = j1,...,n,
x &#x2208; Bn,y &#x2208; Bn,z1 &#x2208; Bm, z2 &#x2208; Bm.
         " class="math-display" ></center></td><td class="equation-label">(1)</td></tr></table>
         <!--l. 673--><p class="nopar" >
         Note that the left hand side of each constraint takes values between 0 and&#x00A0;5, at most, for binary
         variables.
         </li>
         <li class="itemize">Weight the equality for clause <span 
class="cmmi-10">j </span>by 10<sup><span 
class="cmmi-7">j</span><span 
class="cmsy-7">-</span><span 
class="cmr-7">1</span></sup>. Weight the equality for variable <span 
class="cmmi-10">i </span>by 10<sup><span 
class="cmmi-7">m</span><span 
class="cmr-7">+</span><span 
class="cmmi-7">i</span><span 
class="cmsy-7">-</span><span 
class="cmr-7">1</span></sup>.
         To ease the notation, let <span 
class="cmmi-10">x </span><span 
class="cmsy-10">&#x2208; </span><span 
class="msbm-10">B</span><sup><span 
class="cmr-7">2</span><span 
class="cmmi-7">n</span><span 
class="cmr-7">+2</span><span 
class="cmmi-7">m</span></sup> denote the vector of all the variables. Add to give
         <span 
class="cmmi-10">a</span><sup><span 
class="cmmi-7">T</span></sup><span 
class="cmmi-10">x </span>= <span 
class="cmmi-10">b</span>.
         </li>
         <li class="itemize">Note that if <span 
class="cmmi-10">a</span><sup><span 
class="cmmi-7">T</span></sup><span 
class="cmmi-10">x </span>= <span 
class="cmmi-10">b </span>then all the equalities in&#x00A0;(<a 
href="#x1-34r1">1<!--tex4ht:ref: eq:3satIP --></a>) must hold, because of the limited range of the left hand
         sides of the constraints.
         </li>
         <li class="itemize">We can then get the equivalent <span 
class="cmcsc-10">0-1 K<span 
class="small-caps">n</span><span 
class="small-caps">a</span><span 
class="small-caps">p</span><span 
class="small-caps">s</span><span 
class="small-caps">a</span><span 
class="small-caps">c</span><span 
class="small-caps">k</span> </span>problem by taking <span 
class="cmmi-10">c </span>= <span 
class="cmmi-10">a </span>and <span 
class="cmmi-10">&#x03B4; </span>= <span 
class="cmmi-10">b</span>. The reduction is
         polynomial.</li></ul>
     </li></ol>
                                                                                         
                                                                                         
   <div class="tabular"> <table id="TBL-1" class="tabular" 
cellspacing="0" cellpadding="0"  
><colgroup id="TBL-1-1g"><col 
id="TBL-1-1"></colgroup><tr  
 style="vertical-align:baseline;" id="TBL-1-1-"><td  style="white-space:nowrap; text-align:left;" id="TBL-1-1-1"  
class="td01">&#x00A0;&#x00A0;&#x00A0;           <a 
href="http://www.rpi.edu/~mitchj" >John Mitchell</a>                                                      </td></tr><tr  
 style="vertical-align:baseline;" id="TBL-1-2-"><td  style="white-space:nowrap; text-align:left;" id="TBL-1-2-1"  
class="td01">&#x00A0;&#x00A0;&#x00A0; Amos Eaton 325</td>
</tr><tr  
 style="vertical-align:baseline;" id="TBL-1-3-"><td  style="white-space:nowrap; text-align:left;" id="TBL-1-3-1"  
class="td01">&#x00A0;&#x00A0;&#x00A0;           x6915.                                                                </td></tr><tr  
 style="vertical-align:baseline;" id="TBL-1-4-"><td  style="white-space:nowrap; text-align:left;" id="TBL-1-4-1"  
class="td01">&#x00A0;&#x00A0;&#x00A0; <a 
href="mailto:mitchj@rpi.edu" >mitchj at rpi dot edu</a></td>
</tr><tr  
 style="vertical-align:baseline;" id="TBL-1-5-"><td  style="white-space:nowrap; text-align:left;" id="TBL-1-5-1"  
class="td01">&#x00A0;&#x00A0;&#x00A0;           Office hours: Tuesdays 2&#8211;3pm, Wednesdays 11am&#8211;1pm.</td> </tr></table>
</div>
    
</body></html> 

                                                                                         


